<!-- Copyright 2020 Rohit Goswami <rog32@hi.is>
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License. -->
<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SymEngine C++ API: /home/runner/work/symengine/symengine/symengine/mp_boost.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
  loader: { load: ["[tex]/unicode", "[tex]/ams"] },
  tex: {
    packages: { "[+]": ["unicode", "ams"] },
    tags: "ams",
  },
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css" /> -->
<link href="doxyYoda.min.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" >
$(document).ready(function() {
     $(".fragment").wrap("<details class='code-details'></details>");
     $(".code-details").append("<summary>Code</summary>");
 }
)
</script>
</head>
<body>
<div class="grid-contents">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<nav class="title_area">
<span class="project_info">SymEngine C++ API </span>
</nav>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5f3c0b4b33d21f966cb3219df2063971.html">symengine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">mp_boost.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &quot;mp_class.h&quot;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;boost/multiprecision/miller_rabin.hpp&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;boost/mpl/int.hpp&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &lt;symengine/symengine_assert.h&gt;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &lt;symengine/symengine_exception.h&gt;</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &lt;symengine/prime_sieve.h&gt;</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">using</span> boost::multiprecision::denominator;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">using</span> boost::multiprecision::miller_rabin_test;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">using</span> boost::multiprecision::numerator;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="keyword">using</span> boost::multiprecision::detail::find_lsb;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#if SYMENGINE_INTEGER_CLASS == SYMENGINE_BOOSTMP</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceSymEngine.html">SymEngine</a></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;integer_class pow(<span class="keyword">const</span> integer_class &amp;a, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> b)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;{</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="keywordflow">return</span> boost::multiprecision::pow(a, numeric_cast&lt;unsigned&gt;(b));</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keywordtype">void</span> mp_fdiv_qr(integer_class &amp;q, integer_class &amp;r, <span class="keyword">const</span> integer_class &amp;a,</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                <span class="keyword">const</span> integer_class &amp;b)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="comment">/*boost::multiprecision doesn&#39;t have a built-in fdiv_qr (floored division).</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">      Its divide_qr uses truncated division, as does its</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">      modulus operator. Thus, using boost::multiprecision::divide_qr we get:</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">      divide_qr(-5, 3, quo, rem) //quo == -1, rem == -2</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">      divide_qr(5, -3, quo, rem) //quo == -1, rem == 2</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">      but we want:</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">      mp_fdiv_r(quo, rem, -5, 3) //quo == -2, rem == 1</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">      mp_fdiv_r(quo, rem, 5, -3) //rem == -2, rem == -1</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">      The problem arises only when the quotient is negative.  To convert</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">      a truncated result into a floored result in this case, simply subtract</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">      one from the truncated quotient and add the divisor to the truncated</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">      remainder.</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">      */</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="comment">// must copy a and b before calling divide_qr because a or b may refer to</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="comment">// the same</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// object as q or r, causing incorrect results</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    integer_class a_cpy = a, b_cpy = b;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordtype">bool</span> neg_quotient = ((a &lt; 0 &amp;&amp; b &gt; 0) || (a &gt; 0 &amp;&amp; b &lt; 0)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    boost::multiprecision::divide_qr(a_cpy, b_cpy, q, r);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="comment">// floor the quotient if necessary</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">if</span> (neg_quotient &amp;&amp; r != 0) {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        q -= 1;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="comment">// remainder should have same sign as divisor</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">if</span> ((b_cpy &gt; 0 &amp;&amp; r &lt; 0) || (b_cpy &lt; 0 &amp;&amp; r &gt; 0)) {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        r += b_cpy;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="keywordtype">void</span> mp_cdiv_qr(integer_class &amp;q, integer_class &amp;r, <span class="keyword">const</span> integer_class &amp;a,</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                <span class="keyword">const</span> integer_class &amp;b)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    integer_class a_cpy = a, b_cpy = b;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="keywordtype">bool</span> pos_quotient = ((a &lt; 0 &amp;&amp; b &lt; 0) || (a &gt; 0 &amp;&amp; b &gt; 0)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    boost::multiprecision::divide_qr(a_cpy, b_cpy, q, r);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="comment">// ceil the quotient if necessary</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">if</span> (pos_quotient &amp;&amp; r != 0) {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        q += 1;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="comment">// remainder should have opposite sign as divisor</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">if</span> ((b_cpy &gt; 0 &amp;&amp; r &gt; 0) || (b_cpy &lt; 0 &amp;&amp; r &lt; 0)) {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        r -= b_cpy;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;}</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160; </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="keywordtype">void</span> mp_gcdext(integer_class &amp;<a class="code" href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">gcd</a>, integer_class &amp;s, integer_class &amp;t,</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;               <span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;b)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160; </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    integer_class this_s(1);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    integer_class this_t(0);</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    integer_class next_s(0);</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    integer_class next_t(1);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    integer_class this_r(a);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    integer_class next_r(b);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    integer_class q;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">while</span> (next_r != 0) {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="comment">// should use truncated division, so use</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="comment">// boost::multiprecision::divide_qr</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="comment">// beware of overwriting this_r during internal operations of divide_qr</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="comment">// copy it first</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        integer_class this_r_cpy = this_r;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        boost::multiprecision::divide_qr(this_r_cpy, next_r, q, this_r);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        this_s -= q * next_s;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        this_t -= q * next_t;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        std::swap(this_s, next_s);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        std::swap(this_t, next_t);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        std::swap(this_r, next_r);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="comment">// normalize the gcd, s and t</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">if</span> (this_r &lt; 0) {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        this_r *= -1;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        this_s *= -1;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        this_t *= -1;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <a class="code" href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">gcd</a> = std::move(this_r);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    s = std::move(this_s);</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    t = std::move(this_t);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;}</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="keywordtype">bool</span> mp_invert(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;a,</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;               <span class="keyword">const</span> integer_class &amp;m)</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;{</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    integer_class <a class="code" href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">gcd</a>, s, t;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    mp_gcdext(<a class="code" href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">gcd</a>, s, t, a, m);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">gcd</a> != 1) {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        res = 0;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        mp_fdiv_r(s, s, m); <span class="comment">// reduce s modulo m.  undefined behavior when m ==</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                            <span class="comment">// 0, so don&#39;t need to check</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">if</span> (s &lt; 0) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            s += mp_abs(m);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        } <span class="comment">// give the canonical representative of s</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        res = s;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    }</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160; </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">// floored modulus</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;integer_class fmod(<span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;<a class="code" href="namespaceSymEngine.html#a2cee70993b6160daf2870c1a5dc0a532">mod</a>)</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;{</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    integer_class res = a % <a class="code" href="namespaceSymEngine.html#a2cee70993b6160daf2870c1a5dc0a532">mod</a>;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordflow">if</span> (res &lt; 0) {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        res += <a class="code" href="namespaceSymEngine.html#a2cee70993b6160daf2870c1a5dc0a532">mod</a>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;}</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="keywordtype">void</span> mp_pow_ui(rational_class &amp;res, <span class="keyword">const</span> rational_class &amp;i, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;{</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    integer_class num = numerator(i);   <span class="comment">// copy</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    integer_class den = denominator(i); <span class="comment">// copy</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    num = pow(num, n);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    den = pow(den, n);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    res = rational_class(std::move(num), std::move(den));</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;}</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160; </div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="keywordtype">void</span> mp_powm(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;base,</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;             <span class="keyword">const</span> integer_class &amp;<a class="code" href="namespaceSymEngine.html#a59e3d537409ce295f1a798525ed39df1">exp</a>, <span class="keyword">const</span> integer_class &amp;m)</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;{</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="comment">// if exp is negative, interpret as follows</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="comment">// base**(exp) mod m    == (base**(-1))**abs(exp) mod m</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">//                      == (base**(-1) mod m) ** abs(exp) mod m</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="comment">// where base**(-1) mod m is the modular inverse</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSymEngine.html#a59e3d537409ce295f1a798525ed39df1">exp</a> &lt; 0) {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        integer_class base_inverse;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordflow">if</span> (!mp_invert(base_inverse, base, m)) {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="keywordflow">throw</span> SymEngine::SymEngineException(<span class="stringliteral">&quot;negative exponent undefined &quot;</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                                                <span class="stringliteral">&quot;in powm if base is not &quot;</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                                <span class="stringliteral">&quot;invertible mod m&quot;</span>);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        res = boost::multiprecision::powm(base_inverse, mp_abs(<a class="code" href="namespaceSymEngine.html#a59e3d537409ce295f1a798525ed39df1">exp</a>), m);</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        res = boost::multiprecision::powm(base, <a class="code" href="namespaceSymEngine.html#a59e3d537409ce295f1a798525ed39df1">exp</a>, m);</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="comment">// boost&#39;s powm calculates base**exp % m, but uses truncated</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="comment">// modulus, e.g. powm(-2,3,5) == -3.  We want powm(-2,3,5) == 2</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">if</span> (res &lt; 0) {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            res += m;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        }</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160; </div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;integer_class step(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> &amp;n, <span class="keyword">const</span> integer_class &amp;i,</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                   integer_class &amp;x)</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;{</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    SYMENGINE_ASSERT(n &gt; 1);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m = n - 1;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    integer_class &amp;&amp;x_m = pow(x, m);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordflow">return</span> integer_class((integer_class(m * x) + integer_class(i / x_m)) / n);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;}</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160; </div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="keywordtype">bool</span> positive_root(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;i,</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    integer_class x</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        = 1; <span class="comment">// TODO: make a better starting guess based on (number of bits)/n</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    integer_class y = step(n, i, x);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">do</span> {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        x = y;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        y = step(n, i, x);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    } <span class="keywordflow">while</span> (y &lt; x);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    res = x;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">if</span> (pow(x, n) == i) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160; </div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">// return true if i is a perfect nth power, i.e. res**i == n</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="keywordtype">bool</span> mp_root(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;0th root is undefined&quot;</span>);</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">if</span> (n == 1) {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        res = i;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    }</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">if</span> (i == 0) {</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        res = 0;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keywordflow">if</span> (i &gt; 0) {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordflow">return</span> positive_root(res, i, n);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">if</span> (i &lt; 0 &amp;&amp; (n % 2 == 0)) {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;even root of a negative is non-real&quot;</span>);</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordtype">bool</span> b = positive_root(res, -i, n);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    res *= -1;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;integer_class mp_sqrt(<span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;{</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="comment">// as of 11/1/2016, boost::multiprecision::sqrt() is buggy:</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="comment">// https://svn.boost.org/trac/boost/ticket/12559</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// implement with mp_root for now</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    integer_class res;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    mp_root(res, i, 2);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;}</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160; </div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="keywordtype">void</span> mp_rootrem(integer_class &amp;a, integer_class &amp;b, <span class="keyword">const</span> integer_class &amp;i,</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;{</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    mp_root(a, i, n);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    integer_class p = pow(a, n);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    ;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    b = i - p;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160; </div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="keywordtype">void</span> mp_sqrtrem(integer_class &amp;a, integer_class &amp;b, <span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;{</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    a = mp_sqrt(i);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    b = i - boost::multiprecision::pow(a, 2);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;}</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160; </div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">// return nonzero if i is probably prime.</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="keywordtype">int</span> mp_probab_prime_p(<span class="keyword">const</span> integer_class &amp;i, <span class="keywordtype">unsigned</span> retries)</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keywordflow">if</span> (i % 2 == 0)</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <span class="keywordflow">return</span> (i == 2);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">return</span> miller_rabin_test(i, retries);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;}</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="keywordtype">void</span> mp_nextprime(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;{</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="comment">// simple implementation:  just check all odds bigger than i for primality</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">if</span> (i &lt; 2) {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        res = 2;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    integer_class candidate;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    candidate = (i % 2 == 0) ? i + 1 : i + 2;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="comment">// Knuth recommends 25 trials for a pretty strong likelihood that candidate</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="comment">// is prime</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">while</span> (!mp_probab_prime_p(candidate, 25)) {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        candidate += 2;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    res = std::move(candidate);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;}</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160; </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mp_scan1(<span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;{</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keywordflow">if</span> (i == 0) {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keywordflow">return</span> ULONG_MAX;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keywordflow">return</span> find_lsb(i, {});</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;}</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160; </div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">// define simple 2x2 matrix with exponentiation by repeated squaring</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">// to use in logarithmic-time fibonacci calculation</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160; </div>
<div class="line"><a name="l00287"></a><span class="lineno"><a class="line" href="structSymEngine_1_1two__by__two__matrix.html">  287</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    integer_class data[2][2]; <span class="comment">// data[1][0] is row 1, column 0 entry of matrix</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160; </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a>(integer_class a, integer_class b, integer_class c,</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                      integer_class d)</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        : data{{a, b}, {c, d}}</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    }</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a>() : data{{0, 0}, {0, 0}} {}</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a>(<span class="keyword">const</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> &amp;other) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> &amp;other)</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        this-&gt;data[0][0] = other.data[0][0];</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        this-&gt;data[0][1] = other.data[0][1];</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        this-&gt;data[1][0] = other.data[1][0];</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        this-&gt;data[1][1] = other.data[1][1];</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> operator*(<span class="keyword">const</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> &amp;other)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> res;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        res.data[0][0] = this-&gt;data[0][0] * other.data[0][0]</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                         + this-&gt;data[0][1] * other.data[1][0];</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        res.data[0][1] = this-&gt;data[0][0] * other.data[0][1]</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                         + this-&gt;data[0][1] * other.data[1][1];</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        res.data[1][0] = this-&gt;data[1][0] * other.data[0][0]</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                         + this-&gt;data[1][1] * other.data[1][0];</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        res.data[1][1] = this-&gt;data[1][0] * other.data[0][1]</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                         + this-&gt;data[1][1] * other.data[1][1];</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="comment">// recursive repeated squaring</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> pow(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    {</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">return</span> two_by_two_matrix::identity();</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        }</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">if</span> (n == 1) {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordflow">if</span> (n == 2) {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            <span class="keywordflow">return</span> (*<span class="keyword">this</span>) * (*this);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        }</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">if</span> (n % 2 == 0) {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            <span class="keywordflow">return</span> (this-&gt;pow(n / 2)).pow(2);</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">return</span> ((this-&gt;pow((n - 1) / 2)).pow(2)) * (*this);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160; </div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keyword">static</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> identity()</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a>(1, 0, 0, 1);</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;};</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160; </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="keyword">inline</span> <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> fib_matrix(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;{</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <a class="code" href="structSymEngine_1_1two__by__two__matrix.html">two_by_two_matrix</a> x(1, 1, 1, 0);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">return</span> x.pow(n);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;}</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160; </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="keywordtype">void</span> mp_fib_ui(integer_class &amp;res, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;{</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="comment">// reference: https://www.nayuki.io/page/fast-fibonacci-algorithms</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    res = fib_matrix(n).data[0][1];</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;}</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160; </div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">// sets a = Fibonacci(n) and b = Fibonacci(n-1)</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="keywordtype">void</span> mp_fib2_ui(integer_class &amp;a, integer_class &amp;b, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;{</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="comment">// reference: https://www.nayuki.io/page/fast-fibonacci-algorithms</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    two_by_two_matrix result_matrix = fib_matrix(n);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    a = result_matrix.data[0][1];</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    b = result_matrix.data[1][1];</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160; </div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="keyword">inline</span> two_by_two_matrix luc_matrix(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;{</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    two_by_two_matrix multiplier(1, 1, 1, 0);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    two_by_two_matrix start(1, 0, 2, 0);</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">return</span> multiplier.pow(n) * start;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160; </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="keywordtype">void</span> mp_lucnum_ui(integer_class &amp;res, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;{</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="comment">// implementation based on the following fact:</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="comment">// [[1,1],[1,0]]^(n-1)*[2,0,1,0] = [[L(n+1),0][L(n),0]]</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">// where L(n) is the nth Lucas number</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    res = luc_matrix(n).data[1][0];</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;}</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160; </div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="keywordtype">void</span> mp_lucnum2_ui(integer_class &amp;a, integer_class &amp;b, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;{</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;index of lucas number cannot be negative&quot;</span>);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    }</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    two_by_two_matrix result_matrix = luc_matrix(n - 1);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    a = result_matrix.data[0][0];</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    b = result_matrix.data[1][0];</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;}</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160; </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="keywordtype">void</span> mp_fac_ui(integer_class &amp;res, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;{</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// couldn&#39;t make boost&#39;s template version of factorial work,</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// so implement slow, naive version for now</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    res = 1;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 2; i &lt;= n; ++i) {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        res *= i;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;}</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160; </div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="keywordtype">void</span> mp_bin_ui(integer_class &amp;res, <span class="keyword">const</span> integer_class &amp;n, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> r)</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;{</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="comment">// slow, naive implementation</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    integer_class x = n - r;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    res = 1;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 1; i &lt;= r; ++i) {</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        res *= x + i;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        res /= i;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    }</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;}</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160; </div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">// this is extremely slow!</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="keywordtype">bool</span> mp_perfect_power_p(<span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;{</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">if</span> (i == 0 || i == 1 || i == -1) {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">// if i == a**k, with k == pq for some integers p,q</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="comment">// then i == a**(pq) == (a**p)**q == (a**q)**p</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="comment">// hence i is a pth power and a qth power</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">// Hence if i == p**k, then i is a pth power for any p</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// in the prime factorization of k, and it suffices</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="comment">// to check whether i is a prime power.</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="comment">// the largest possible prime p would arise from the</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="comment">// case where i is a prime power of two</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="comment">// so check all prime roots up to log(i) base 2.</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160; </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="namespaceSymEngine.html#a266cbfda523325a93b19b5dd2f113862">max</a> = std::ilogb(i.convert_to&lt;<span class="keywordtype">double</span>&gt;());</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160; </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// treat case p=2 separately b/c mp_root throws exception</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="comment">// with an even root of a negative</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">if</span> (mp_perfect_square_p(i)) {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    }</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    integer_class p(2);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    integer_class root(0);</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        mp_nextprime(p, p);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        <span class="keywordflow">if</span> (p &gt; <a class="code" href="namespaceSymEngine.html#a266cbfda523325a93b19b5dd2f113862">max</a>) {</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        }</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">if</span> (mp_root(root, i, p.convert_to&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt;())) {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;}</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160; </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="keywordtype">bool</span> mp_perfect_square_p(<span class="keyword">const</span> integer_class &amp;i)</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;{</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="keywordflow">if</span> (i &lt; 0) {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    }</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    integer_class root;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">return</span> mp_root(root, i, 2);</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;}</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160; </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;integer_class mp_primorial(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n)</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;{</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    integer_class res = 1;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    Sieve::iterator pi(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(n));</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">while</span> ((p = pi.next_prime()) &lt;= n) {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        res *= p;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;}</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160; </div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">// according to the gmp documentation, the behavior of the</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">// corresponding function mpz_legendre is</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">// undefined if n is not a positive odd prime.</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">// hence we treat n as though it were a positive odd prime</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment">// but it is up to the caller to very this.</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="keywordtype">int</span> mp_legendre(<span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;n)</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;{</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    integer_class res;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    mp_powm(res, a, integer_class((n - 1) / 2), n);</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keywordflow">return</span> res &lt;= 1 ? res.convert_to&lt;<span class="keywordtype">int</span>&gt;() : -1;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;}</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160; </div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment">// private function that computes jacobi symbols</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">// without checking that arguments satisfy a &gt;= 0</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">// and n is odd.</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="keywordtype">int</span> unchecked_jacobi(<span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;n)</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;{</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="comment">// https://en.wikipedia.org/wiki/Jacobi_symbol#Calculating_the_Jacobi_symbol</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keywordflow">if</span> (a == 1) {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    }</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    integer_class num = a;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    integer_class den = n;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="comment">// (1) Reduce the &quot;numerator&quot; modulo the &quot;denominator&quot;</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    num = fmod(num, den);</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="comment">// (2) Extract any factors of 2 from the &quot;numerator&quot;</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factors_of_two = 0;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">while</span> (num % 2 == 0 &amp;&amp; num != 0) {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        num /= 2; <span class="comment">// use a shift instead of division here? faster?</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        ++factors_of_two;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    }</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordtype">int</span> product_of_twos = 1; <span class="comment">// (2 | den)**factors_of_two</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160; </div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <span class="comment">// (2 | den) is -1 iff den % 8 = 3 or den % 8 = 5.</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="comment">// If factors_of_two is odd and (2 | den) is -1,</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    <span class="comment">// then (2 | den)**factors_of_two is -1.</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    <span class="comment">// Otherwise, (2 | den)**factors_of_two is 1.</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keywordtype">int</span> den_mod_8 = fmod(den, 8).convert_to&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="keywordflow">if</span> ((factors_of_two % 2 == 1) &amp;&amp; (den_mod_8 == 3 || den_mod_8 == 5)) {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        product_of_twos = -1;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160; </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="comment">// (3) If the remaining &quot;numerator&quot; (after extraction of twos) is 1,</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="comment">// then the remaining jacobi symbol is 1.</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="comment">// If the &quot;numerator&quot; and &quot;denominator&quot; are not coprime, result is 0.</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    <span class="keywordflow">if</span> (num == 1) {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordflow">return</span> product_of_twos;</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    }</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordflow">if</span> (boost::multiprecision::gcd(num, den) != 1) {</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160; </div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="comment">// (4) Otherwise, the &quot;numerator&quot; and &quot;denominator&quot; are now odd</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="comment">// positive coprime integers, so we can flip the symbol</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="comment">// with quadratic reciprocity, then return to step (1)</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160; </div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="comment">// (num | den) == (den | num), unless num % 4 and den %4 are both</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    <span class="comment">// 3, in which case (num | den) == (-1) * (den | num)</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordtype">int</span> quadratic_reciprocity_factor = 1;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keywordflow">if</span> ((fmod(num, 4) == 3) &amp;&amp; (fmod(den, 4) == 3)) {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        quadratic_reciprocity_factor = -1;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    }</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="keywordflow">return</span> product_of_twos * quadratic_reciprocity_factor</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;           * unchecked_jacobi(den, num);</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;}</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160; </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment">// public interface for computing jacobi symbols.  performs checking.</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="keywordtype">int</span> mp_jacobi(<span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;n)</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;{</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    <span class="keywordflow">if</span> (n &lt; 0) {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;jacobi denominator must be positive&quot;</span>);</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordflow">if</span> (n % 2 == 0) {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;jacobi denominator must be odd&quot;</span>);</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    <span class="keywordflow">return</span> unchecked_jacobi(a, n);</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;}</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160; </div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="keywordtype">int</span> mp_kronecker(<span class="keyword">const</span> integer_class &amp;a, <span class="keyword">const</span> integer_class &amp;n)</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;{</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="comment">/*</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment">    https://en.wikipedia.org/wiki/Kronecker_symbol</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment">    We compute the Kronecker symbol in terms of the Jacobi symbol.</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment">    For an integer n!=0, let n = u * PRODUCT (p_i**e_i), where u = -1 or 1 and</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment">    the p_i&#39;s and e_i&#39;s are the primes and corresponding powers</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">    in the prime factorization of |n|.</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment">    Then for an integer a, the Kronecker symbol is given by</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment">    (a | n) = (a | u) * PRODUCT [(a | p_i)**e_i]</span></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment">    where</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">    (a | u) is -1 if u is -1 and a &lt; 0. Otherwise it is 1.</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">    (a | 2) is 0 if a is even, 1 if (a mod 8) == 1 or 7, and -1 if (a mod 8) ==</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">    3 or 5.</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">    (a | p) is the Legendre symbol if p is an odd prime.</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">    Let j be the power of the prime 2 in n&#39;s prime factorization, and let</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">    m = |n|/(2**j) -- that is, m is |n| with all factors of 2 extracted.</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">    Notice that, if p_1 is 2, then</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">    PRODUCT [(a | p_i)**e_i]</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment">    == (a | 2)**j * PRODUCT [(a | p_i)**e_i]    here the p_i&#39;s are the remaining</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment">    (odd) prime factors</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">    == (a | 2)**j * (a | m),                    here (a | m) is the Jacobi</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">    symbol, because m&gt;0 is odd</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment">    Thus,</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment">    (a | n) == (a | u) * (a | 2)**j * (a | m)   if n is even</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">    (a | n) == (a | u) * (a | m)                if n is odd</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">    */</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160; </div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <span class="keywordflow">if</span> (n == 0) {</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;second arg of Kronecker cannot be zero&quot;</span>);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    }</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160; </div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    <span class="comment">// Compute (a | u)</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    <span class="keywordtype">int</span> kr_a_u = 1;</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="keywordflow">if</span> (n.sign() == -1 &amp;&amp; a &lt; 0) {</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        kr_a_u = -1;</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    }</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160; </div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="comment">// Compute m, j</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    integer_class m = boost::multiprecision::abs(n);</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j = 0;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordflow">while</span> (m % 2 == 0 &amp;&amp; m != 0) { <span class="comment">// while m is even</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        m /= 2;                    <span class="comment">// implement with shift?  faster?</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        ++j;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    }</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160; </div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="comment">// if n is even, compute (a | 2)**j</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordtype">int</span> kr_a_2 = 0;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="keywordtype">int</span> kr_a_2_to_j = 0;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keywordtype">int</span> a_mod_8 = fmod(a, 8).convert_to&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160; </div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">if</span> (a % 2 != 0) {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        kr_a_2 = (a_mod_8 == 1 || a_mod_8 == 7) ? 1 : -1;</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        kr_a_2_to_j = (kr_a_2 == -1 &amp;&amp; (j % 2 != 0))</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                          ? -1</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                          : 1; <span class="comment">//(-1)**odd == -1; (-1)**even=(1)**integer=1</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    }</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160; </div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    <span class="keywordflow">if</span> (n % 2 == 0) {</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keywordflow">return</span> kr_a_u * kr_a_2_to_j * unchecked_jacobi(a, m);</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <span class="keywordflow">return</span> kr_a_u * unchecked_jacobi(a, m);</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    }</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;}</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160; </div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;} <span class="comment">// namespace SymEngine</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160; </div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="preprocessor">#endif </span><span class="comment">// SYMENGINE_INTEGER_CLASS == SYMENGINE_BOOSTMP</span></div>
<div class="ttc" id="anamespaceSymEngine_html"><div class="ttname"><a href="namespaceSymEngine.html">SymEngine</a></div><div class="ttdoc">Main namespace for SymEngine package.</div><div class="ttdef"><b>Definition:</b> <a href="add_8cpp_source.html#l00018">add.cpp:19</a></div></div>
<div class="ttc" id="anamespaceSymEngine_html_a23e7d19677dfaf17bce40fd767860bfd"><div class="ttname"><a href="namespaceSymEngine.html#a23e7d19677dfaf17bce40fd767860bfd">SymEngine::gcd</a></div><div class="ttdeci">RCP&lt; const Integer &gt; gcd(const Integer &amp;a, const Integer &amp;b)</div><div class="ttdoc">Greatest Common Divisor.</div><div class="ttdef"><b>Definition:</b> <a href="ntheory_8cpp_source.html#l00032">ntheory.cpp:32</a></div></div>
<div class="ttc" id="anamespaceSymEngine_html_a266cbfda523325a93b19b5dd2f113862"><div class="ttname"><a href="namespaceSymEngine.html#a266cbfda523325a93b19b5dd2f113862">SymEngine::max</a></div><div class="ttdeci">RCP&lt; const Basic &gt; max(const vec_basic &amp;arg)</div><div class="ttdoc">Canonicalize Max:</div><div class="ttdef"><b>Definition:</b> <a href="functions_8cpp_source.html#l03555">functions.cpp:3555</a></div></div>
<div class="ttc" id="anamespaceSymEngine_html_a2cee70993b6160daf2870c1a5dc0a532"><div class="ttname"><a href="namespaceSymEngine.html#a2cee70993b6160daf2870c1a5dc0a532">SymEngine::mod</a></div><div class="ttdeci">RCP&lt; const Integer &gt; mod(const Integer &amp;n, const Integer &amp;d)</div><div class="ttdoc">modulo round toward zero</div><div class="ttdef"><b>Definition:</b> <a href="ntheory_8cpp_source.html#l00067">ntheory.cpp:67</a></div></div>
<div class="ttc" id="anamespaceSymEngine_html_a59e3d537409ce295f1a798525ed39df1"><div class="ttname"><a href="namespaceSymEngine.html#a59e3d537409ce295f1a798525ed39df1">SymEngine::exp</a></div><div class="ttdeci">RCP&lt; const Basic &gt; exp(const RCP&lt; const Basic &gt; &amp;x)</div><div class="ttdoc">Returns the natural exponential function E**x = pow(E, x)</div><div class="ttdef"><b>Definition:</b> <a href="pow_8cpp_source.html#l00271">pow.cpp:271</a></div></div>
<div class="ttc" id="astructSymEngine_1_1two__by__two__matrix_html"><div class="ttname"><a href="structSymEngine_1_1two__by__two__matrix.html">SymEngine::two_by_two_matrix</a></div><div class="ttdef"><b>Definition:</b> <a href="mp__boost_8cpp_source.html#l00287">mp_boost.cpp:287</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- Copyright 2020 Rohit Goswami <rog32@hi.is>
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License. -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div class="footer">
<hr class="footline"/><address class="footline"><small>
    Generated by&#160;<a href="https://www.doxygen.org/index.html">Doxygen 1.9.1</a> and the <a class="outlink" href="https://github.com/HaoZeke/doxyYoda">doxyYoda theme</a>
</small></address>
</div>
</div>
</body>
</html>
